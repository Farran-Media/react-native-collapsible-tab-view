{"version":3,"names":["_react","require","_reactNative","_reactNativeReanimated","_useDeepCompare","_Context","_helpers","useContainerRef","useAnimatedRef","useAnimatedDynamicRefs","map","setMap","useState","setRef","useCallback","key","ref","useTabProps","children","tabType","options","useMemo","tabOptions","Map","Children","forEach","element","index","type","Error","name","props","has","set","optionEntries","Array","from","entries","optionKeys","keys","memoizedOptions","useDeepCompareMemo","memoizedTabNames","useTabsContext","c","useContext","Context","useTabNameContext","TabNameContext","useLayoutHeight","initialHeight","height","setHeight","getHeight","event","latestHeight","nativeEvent","layout","useCollapsibleStyle","headerHeight","tabBarHeight","containerHeight","width","allowHeaderOverscroll","minHeaderHeight","containerHeightWithMinHeader","Math","max","style","contentContainerStyle","minHeight","IS_IOS","paddingTop","progressViewOffset","useUpdateScrollViewContentSize","tabNames","contentHeights","setContentHeights","tabIndex","value","indexOf","scrollContentSizeChange","_","h","runOnUI","useChainCallback","fns","callAll","args","fn","useScroller","contentInset","scroller","x","y","animated","_debugKey","scrollToImpl","useScrollHandlerY","accDiffClamp","focusedTab","snapThreshold","revealHeaderOnScroll","refMap","scrollYCurrent","scrollY","oldAccScrollY","accScrollY","offset","headerScrollDistance","snappingTo","indexDecimal","enabled","useSharedValue","scrollTo","enable","toggle","afterDrag","scrollAnimation","undefined","useAnimatedReaction","val","onMomentumEnd","withTiming","scrollHandler","useAnimatedScrollHandler","onScroll","contentOffset","contentHeight","Number","MAX_VALUE","clampMax","interpolate","Extrapolation","CLAMP","delta","nextValue","min","onBeginDrag","cancelAnimation","onEndDrag","withDelay","ONE_FRAME_MS","duration","isFinished","onMomentumBegin","isChangingPane","isInteger","isSyncNeeded","wasSyncNeeded","nextPosition","focusedScrollY","tabScrollY","areEqual","currIsOnTop","StyleSheet","hairlineWidth","focusedIsOnTop","hasGap","exports","useSharedAnimatedRef","outerRef","useEffect","current","useAfterMountEffect","nextOnLayout","effect","didExecute","useRef","didMount","prevDidMount","onLayoutOut","requestAnimationFrame","useConvertAnimatedToValue","animatedValue","setValue","animValue","runOnJS","useHeaderMeasurements","headerTranslateY","top","useCurrentTabScrollY","useFocusedTab","focusedTabValue","useAnimatedTabIndex","usePageScrollHandler","handlers","dependencies","context","doDependenciesDiffer","useHandler","subscribeForEvents","useEvent","onPageScroll","eventName","endsWith"],"sources":["hooks.tsx"],"sourcesContent":["import {\n  useMemo,\n  Children,\n  useState,\n  useCallback,\n  useContext,\n  MutableRefObject,\n  useEffect,\n  useRef,\n} from 'react'\nimport { LayoutChangeEvent, StyleSheet, ViewProps } from 'react-native'\nimport { ContainerRef, RefComponent } from 'react-native-collapsible-tab-view'\nimport { PagerViewOnPageScrollEvent } from 'react-native-pager-view'\nimport Animated, {\n  cancelAnimation,\n  useAnimatedReaction,\n  useAnimatedRef,\n  useAnimatedScrollHandler,\n  useSharedValue,\n  withDelay,\n  withTiming,\n  interpolate,\n  runOnJS,\n  runOnUI,\n  useEvent,\n  useHandler,\n  AnimatedRef,\n  Extrapolation,\n} from 'react-native-reanimated'\nimport { useDeepCompareMemo } from 'use-deep-compare'\n\nimport { Context, TabNameContext } from './Context'\nimport { IS_IOS, ONE_FRAME_MS, scrollToImpl } from './helpers'\nimport {\n  CollapsibleStyle,\n  ContextType,\n  TabName,\n  TabReactElement,\n  TabsWithProps,\n} from './types'\n\nexport function useContainerRef() {\n  return useAnimatedRef<ContainerRef>()\n}\n\nexport function useAnimatedDynamicRefs(): [\n  ContextType['refMap'],\n  ContextType['setRef'],\n] {\n  const [map, setMap] = useState<ContextType['refMap']>({})\n  const setRef = useCallback((key: TabName, ref: AnimatedRef<RefComponent>) => {\n    setMap((map) => ({ ...map, [key]: ref }))\n    return ref\n  }, [])\n\n  return [map, setRef as ContextType['setRef']]\n}\n\nexport function useTabProps<T extends TabName>(\n  children: TabReactElement<T>[] | TabReactElement<T>,\n  tabType: Function\n): [TabsWithProps<T>, T[]] {\n  const options = useMemo(() => {\n    const tabOptions: TabsWithProps<T> = new Map()\n    if (children) {\n      Children.forEach(children, (element, index) => {\n        if (!element) return\n\n        if (element.type !== tabType)\n          throw new Error(\n            'Container children must be wrapped in a <Tabs.Tab ... /> component'\n          )\n\n        // make sure children is excluded otherwise our props will mutate too much\n        const { name, children, ...options } = element.props\n        if (tabOptions.has(name))\n          throw new Error(`Tab names must be unique, ${name} already exists`)\n\n        tabOptions.set(name, {\n          index,\n          name,\n          ...options,\n        })\n      })\n    }\n    return tabOptions\n  }, [children, tabType])\n  const optionEntries = Array.from(options.entries())\n  const optionKeys = Array.from(options.keys())\n  const memoizedOptions = useDeepCompareMemo(() => options, [optionEntries])\n  const memoizedTabNames = useDeepCompareMemo(() => optionKeys, [optionKeys])\n  return [memoizedOptions, memoizedTabNames]\n}\n\n/**\n * Hook exposing some useful variables.\n *\n * ```tsx\n * const { focusedTab, ...rest } = useTabsContext()\n * ```\n */\nexport function useTabsContext(): ContextType<TabName> {\n  const c = useContext(Context)\n  if (!c) throw new Error('useTabsContext must be inside a Tabs.Container')\n  return c\n}\n\n/**\n * Access the parent tab screen from any deep component.\n *\n * ```tsx\n * const tabName = useTabNameContext()\n * ```\n */\nexport function useTabNameContext(): TabName {\n  const c = useContext(TabNameContext)\n  if (!c) throw new Error('useTabNameContext must be inside a TabNameContext')\n  return c\n}\n\nexport function useLayoutHeight(initialHeight: number = 0) {\n  const [height, setHeight] = useState(initialHeight)\n\n  const getHeight = useCallback(\n    (event: LayoutChangeEvent) => {\n      const latestHeight = event.nativeEvent.layout.height\n      if (latestHeight !== height) {\n        setHeight(latestHeight)\n      }\n    },\n    [height, setHeight]\n  )\n  return [height, getHeight] as const\n}\n/**\n * Hook to access some key styles that make the whole thing work.\n *\n * You can use this to get the progessViewOffset and pass to the refresh control of scroll view.\n */\nexport function useCollapsibleStyle(): CollapsibleStyle {\n  const {\n    headerHeight,\n    tabBarHeight,\n    containerHeight,\n    width,\n    allowHeaderOverscroll,\n    minHeaderHeight,\n  } = useTabsContext()\n  const containerHeightWithMinHeader = Math.max(\n    0,\n    (containerHeight ?? 0) - minHeaderHeight\n  )\n\n  return useMemo(\n    () => ({\n      style: { width },\n      contentContainerStyle: {\n        minHeight:\n          IS_IOS && !allowHeaderOverscroll\n            ? containerHeightWithMinHeader - (tabBarHeight || 0)\n            : containerHeightWithMinHeader + (headerHeight || 0),\n        paddingTop:\n          IS_IOS && !allowHeaderOverscroll\n            ? 0\n            : (headerHeight || 0) + (tabBarHeight || 0),\n      },\n      progressViewOffset:\n        // on iOS we need the refresh control to be at the top if overscrolling\n        IS_IOS && allowHeaderOverscroll\n          ? 0\n          : // on android we need it below the header or it doesn't show because of z-index\n            (headerHeight || 0) + (tabBarHeight || 0),\n    }),\n    [\n      allowHeaderOverscroll,\n      headerHeight,\n      tabBarHeight,\n      width,\n      containerHeightWithMinHeader,\n    ]\n  )\n}\n\nexport function useUpdateScrollViewContentSize({ name }: { name: TabName }) {\n  const { tabNames, contentHeights } = useTabsContext()\n  const setContentHeights = useCallback(\n    (name: TabName, height: number) => {\n      'worklet'\n      const tabIndex = tabNames.value.indexOf(name)\n      contentHeights.value[tabIndex] = height\n      contentHeights.value = [...contentHeights.value]\n    },\n    [contentHeights, tabNames]\n  )\n\n  const scrollContentSizeChange = useCallback(\n    (_: number, h: number) => {\n      runOnUI(setContentHeights)(name, h)\n    },\n    [setContentHeights, name]\n  )\n\n  return scrollContentSizeChange\n}\n\n/**\n * Allows specifying multiple functions to be called in a sequence with the same parameters\n * Useful because we handle some events and need to pass them forward so that the caller can handle them as well\n * @param fns array of functions to call\n * @returns a function that once called will call all passed functions\n */\nexport function useChainCallback(fns: (Function | undefined)[]) {\n  const callAll = useCallback(\n    (...args: unknown[]) => {\n      fns.forEach((fn) => {\n        if (typeof fn === 'function') {\n          fn(...args)\n        }\n      })\n    },\n    [fns]\n  )\n  return callAll\n}\n\nexport function useScroller<T extends RefComponent>() {\n  const { contentInset } = useTabsContext()\n\n  const scroller = useCallback(\n    (\n      ref: AnimatedRef<T> | undefined,\n      x: number,\n      y: number,\n      animated: boolean,\n      _debugKey: string\n    ) => {\n      'worklet'\n      if (!ref) return\n      //! this is left here on purpose to ease troubleshooting (uncomment when necessary)\n      // console.log(\n      //   `${_debugKey}, y: ${y}, y adjusted: ${y - contentInset}`\n      // )\n      scrollToImpl(ref, x, y - contentInset, animated)\n    },\n    [contentInset]\n  )\n\n  return scroller\n}\n\nexport const useScrollHandlerY = (name: TabName) => {\n  const {\n    accDiffClamp,\n    focusedTab,\n    snapThreshold,\n    revealHeaderOnScroll,\n    refMap,\n    tabNames,\n    headerHeight,\n    contentInset,\n    containerHeight,\n    scrollYCurrent,\n    scrollY,\n    oldAccScrollY,\n    accScrollY,\n    offset,\n    headerScrollDistance,\n    snappingTo,\n    contentHeights,\n    indexDecimal,\n    allowHeaderOverscroll,\n  } = useTabsContext()\n\n  const enabled = useSharedValue(false)\n\n  const scrollTo = useScroller()\n\n  const enable = useCallback(\n    (toggle: boolean) => {\n      'worklet'\n      enabled.value = toggle\n    },\n    [name, refMap, scrollTo]\n  )\n\n  /**\n   * Helper value to track if user is dragging on iOS, because iOS calls\n   * onMomentumEnd only after a vigorous swipe. If the user has finished the\n   * drag, but the onMomentumEnd has never triggered, we need to manually\n   * call it to sync the scenes.\n   */\n  const afterDrag = useSharedValue(0)\n\n  const scrollAnimation = useSharedValue<number | undefined>(undefined)\n\n  useAnimatedReaction(\n    () => scrollAnimation.value,\n    (val) => {\n      if (val !== undefined) {\n        scrollTo(refMap[name], 0, val, false, '[useAnimatedReaction scroll]')\n      }\n    }\n  )\n\n  const onMomentumEnd = () => {\n    'worklet'\n    if (!enabled.value) return\n\n    if (typeof snapThreshold === 'number') {\n      if (revealHeaderOnScroll) {\n        if (accDiffClamp.value > 0) {\n          if (\n            scrollYCurrent.value >\n            headerScrollDistance.value * snapThreshold\n          ) {\n            if (\n              accDiffClamp.value <=\n              headerScrollDistance.value * snapThreshold\n            ) {\n              // snap down\n              accDiffClamp.value = withTiming(0)\n            } else if (accDiffClamp.value < headerScrollDistance.value) {\n              // snap up\n              accDiffClamp.value = withTiming(headerScrollDistance.value)\n\n              if (scrollYCurrent.value < headerScrollDistance.value) {\n                scrollAnimation.value = scrollYCurrent.value\n                scrollAnimation.value = withTiming(headerScrollDistance.value)\n                //console.log('[${name}] sticky snap up')\n              }\n            }\n          } else {\n            accDiffClamp.value = withTiming(0)\n          }\n        }\n      } else {\n        if (\n          scrollYCurrent.value <=\n          headerScrollDistance.value * snapThreshold\n        ) {\n          // snap down\n          snappingTo.value = 0\n          scrollAnimation.value = scrollYCurrent.value\n          scrollAnimation.value = withTiming(0)\n          //console.log('[${name}] snap down')\n        } else if (scrollYCurrent.value <= headerScrollDistance.value) {\n          // snap up\n          snappingTo.value = headerScrollDistance.value\n          scrollAnimation.value = scrollYCurrent.value\n          scrollAnimation.value = withTiming(headerScrollDistance.value)\n          //console.log('[${name}] snap up')\n        }\n      }\n    }\n  }\n\n  const scrollHandler = useAnimatedScrollHandler(\n    {\n      onScroll: (event) => {\n        if (!enabled.value) return\n\n        if (focusedTab.value === name) {\n          if (IS_IOS) {\n            let { y } = event.contentOffset\n            // normalize the value so it starts at 0\n            y = y + contentInset\n\n            const contentHeight =\n              contentHeights.value[tabNames.value.indexOf(name)] ||\n              Number.MAX_VALUE\n\n            const clampMax =\n              contentHeight - (containerHeight || 0) + contentInset\n            // make sure the y value is clamped to the scrollable size (clamps overscrolling)\n            scrollYCurrent.value = allowHeaderOverscroll\n              ? y\n              : interpolate(\n                  y,\n                  [0, clampMax],\n                  [0, clampMax],\n                  Extrapolation.CLAMP\n                )\n          } else {\n            const { y } = event.contentOffset\n            scrollYCurrent.value = y\n          }\n\n          scrollY.value[name] = scrollYCurrent.value\n          oldAccScrollY.value = accScrollY.value\n          accScrollY.value = scrollY.value[name] + offset.value\n\n          if (revealHeaderOnScroll) {\n            const delta = accScrollY.value - oldAccScrollY.value\n            const nextValue = accDiffClamp.value + delta\n            if (delta > 0) {\n              // scrolling down\n              accDiffClamp.value = Math.min(\n                headerScrollDistance.value,\n                nextValue\n              )\n            } else if (delta < 0) {\n              // scrolling up\n              accDiffClamp.value = Math.max(0, nextValue)\n            }\n          }\n        }\n      },\n      onBeginDrag: () => {\n        if (!enabled.value) return\n\n        // ensure the header stops snapping\n        cancelAnimation(accDiffClamp)\n\n        if (IS_IOS) cancelAnimation(afterDrag)\n      },\n      onEndDrag: () => {\n        if (!enabled.value) return\n\n        if (IS_IOS) {\n          // we delay this by one frame so that onMomentumBegin may fire on iOS\n          afterDrag.value = withDelay(\n            ONE_FRAME_MS,\n            withTiming(0, { duration: 0 }, (isFinished) => {\n              // if the animation is finished, the onMomentumBegin has\n              // never started, so we need to manually trigger the onMomentumEnd\n              // to make sure we snap\n              if (isFinished) {\n                onMomentumEnd()\n              }\n            })\n          )\n        }\n      },\n      onMomentumBegin: () => {\n        if (!enabled.value) return\n\n        if (IS_IOS) {\n          cancelAnimation(afterDrag)\n        }\n      },\n      onMomentumEnd,\n    },\n    [\n      refMap,\n      name,\n      revealHeaderOnScroll,\n      containerHeight,\n      contentInset,\n      snapThreshold,\n      enabled,\n      scrollTo,\n    ]\n  )\n\n  // sync unfocused scenes\n  useAnimatedReaction(\n    () => {\n      // if (!enabled.value) {\n      //   return false\n      // }\n\n      // if the index is decimal, then we're in between panes\n      const isChangingPane = !Number.isInteger(indexDecimal.value)\n\n      return isChangingPane\n    },\n    (isSyncNeeded, wasSyncNeeded) => {\n      if (\n        isSyncNeeded &&\n        isSyncNeeded !== wasSyncNeeded &&\n        focusedTab.value !== name\n      ) {\n        let nextPosition: number | null = null\n        const focusedScrollY = scrollY.value[focusedTab.value]\n        const tabScrollY = scrollY.value[name]\n        const areEqual = focusedScrollY === tabScrollY\n\n        if (!areEqual) {\n          const currIsOnTop =\n            tabScrollY + StyleSheet.hairlineWidth <= headerScrollDistance.value\n          const focusedIsOnTop =\n            focusedScrollY + StyleSheet.hairlineWidth <=\n            headerScrollDistance.value\n\n          if (revealHeaderOnScroll) {\n            const hasGap = accDiffClamp.value > tabScrollY\n            if (hasGap || currIsOnTop) {\n              nextPosition = accDiffClamp.value\n            }\n          } else if (typeof snapThreshold === 'number') {\n            if (focusedIsOnTop) {\n              nextPosition = snappingTo.value\n            } else if (currIsOnTop) {\n              nextPosition = headerHeight || 0\n            }\n          } else if (currIsOnTop || focusedIsOnTop) {\n            nextPosition = Math.min(focusedScrollY, headerScrollDistance.value)\n          }\n        }\n\n        if (nextPosition !== null) {\n          // console.log(`sync ${name} ${nextPosition}`)\n          scrollY.value[name] = nextPosition\n          scrollTo(refMap[name], 0, nextPosition, false, `[${name}] sync pane`)\n        }\n      }\n    },\n    [revealHeaderOnScroll, refMap, snapThreshold, enabled, scrollTo]\n  )\n\n  return { scrollHandler, enable }\n}\n\ntype ForwardRefType<T> =\n  | ((instance: T | null) => void)\n  | MutableRefObject<T | null>\n  | null\n\n/**\n * Magic hook that creates a multicast ref. Useful so that we can both capture the ref, and forward it to callers.\n * Accepts a parameter for an outer ref that will also be updated to the same ref\n * @param outerRef the outer ref that needs to be updated\n * @returns an animated ref\n */\nexport function useSharedAnimatedRef<T extends RefComponent>(\n  outerRef: ForwardRefType<T>\n) {\n  const ref = useAnimatedRef<T>()\n\n  // this executes on every render\n  useEffect(() => {\n    if (!outerRef) {\n      return\n    }\n    if (typeof outerRef === 'function') {\n      outerRef(ref.current)\n    } else {\n      outerRef.current = ref.current\n    }\n  })\n\n  return ref\n}\n\nexport function useAfterMountEffect(\n  nextOnLayout: ViewProps['onLayout'],\n  effect: React.EffectCallback\n) {\n  const didExecute = useRef(false)\n  const didMount = useSharedValue(false)\n\n  useAnimatedReaction(\n    () => {\n      return didMount.value\n    },\n    (didMount, prevDidMount) => {\n      if (didMount && !prevDidMount) {\n        if (didExecute.current) return\n\n        effect()\n        didExecute.current = true\n      }\n    }\n  )\n\n  const onLayoutOut: NonNullable<ViewProps['onLayout']> = useCallback(\n    (event: LayoutChangeEvent) => {\n      requestAnimationFrame(() => {\n        didMount.value = true\n      })\n      return nextOnLayout?.(event)\n    },\n    [didMount, nextOnLayout]\n  )\n\n  return onLayoutOut\n}\n\nexport function useConvertAnimatedToValue<T>(\n  animatedValue: Animated.SharedValue<T>\n) {\n  const [value, setValue] = useState<T>(animatedValue.value)\n\n  useAnimatedReaction(\n    () => {\n      return animatedValue.value\n    },\n    (animValue) => {\n      if (animValue !== value) {\n        runOnJS(setValue)(animValue)\n      }\n    },\n    [value]\n  )\n\n  return value || 0\n}\n\nexport interface HeaderMeasurements {\n  /**\n   * Animated value that represents the current Y translation of the header\n   */\n  top: Animated.SharedValue<number>\n  /**\n   * Animated value that represents the height of the header\n   */\n  height: number\n}\n\nexport function useHeaderMeasurements(): HeaderMeasurements {\n  const { headerTranslateY, headerHeight } = useTabsContext()\n  return {\n    top: headerTranslateY,\n    height: headerHeight,\n  }\n}\n\n/**\n * Returns the vertical scroll position of the current tab as an Animated SharedValue\n */\nexport function useCurrentTabScrollY(): Animated.SharedValue<number> {\n  const { scrollYCurrent } = useTabsContext()\n  return scrollYCurrent\n}\n\n/**\n * Returns the currently focused tab name\n */\nexport function useFocusedTab() {\n  const { focusedTab } = useTabsContext()\n  const focusedTabValue = useConvertAnimatedToValue(focusedTab)\n  return focusedTabValue\n}\n\n/**\n * Returns an animated value representing the current tab index, as a floating point number\n */\nexport function useAnimatedTabIndex() {\n  const { indexDecimal } = useTabsContext()\n  return indexDecimal\n}\n\nexport const usePageScrollHandler = (\n  handlers: {\n    onPageScroll: (\n      event: PagerViewOnPageScrollEvent['nativeEvent'],\n      context: unknown\n    ) => unknown\n  },\n  dependencies?: unknown[]\n) => {\n  const { context, doDependenciesDiffer } = useHandler(handlers, dependencies)\n  const subscribeForEvents = ['onPageScroll']\n\n  return useEvent<any>(\n    (event) => {\n      'worklet'\n      const { onPageScroll } = handlers\n      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {\n        onPageScroll(event, context)\n      }\n    },\n    subscribeForEvents,\n    doDependenciesDiffer\n  )\n}\n"],"mappings":"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","ignoreList":[]}